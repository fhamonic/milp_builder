/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.*/
/**
 * @file milppp.hpp
 * @author François Hamonic (francois.hamonic@gmail.com)
 * @brief 
 * @version 0.1
 * @date 2021-08-05
 * 
 * @copyright Copyright (c) 2021
 * 
 */
#ifndef MILPPP_HPP
#define MILPPP_HPP

/**
 * @file MILP_Builder.hpp
 * @author François Hamonic (francois.hamonic@gmail.com)
 * @brief
 * @version 0.1
 * @date 2021-08-05
 *
 * @copyright Copyright (c) 2021
 *
 */
#ifndef MILPPP_MILP_BUILDER_HPP
#define MILPPP_MILP_BUILDER_HPP

#include <cassert>
#include <limits>
#include <ostream>
#include <range/v3/view/filter.hpp>
#include <range/v3/view/iota.hpp>
#include <range/v3/view/transform.hpp>
#include <range/v3/view/zip.hpp>
#include <vector>

#ifndef MILPPP_FUCTION_TRAITS_HPP
#define MILPPP_FUCTION_TRAITS_HPP

namespace fhamonic {
namespace milppp {

template <typename... Args>
struct pack {};

template <typename T>
struct function_traits : public function_traits<decltype(&T::operator())> {};
template <typename ClassType, typename ReturnType, typename... Args>
struct function_traits<ReturnType (ClassType::*)(Args...) const> {
    using result_type = ReturnType;
    using arg_types = pack<Args...>;
};

}  // namespace milppp
}  // namespace fhamonic

#endif  // MILPPP_FUCTION_TRAITS_HPP
/**
 * @file solver_builder.hpp
 * @author François Hamonic (francois.hamonic@gmail.com)
 * @brief OSI_Builder class declaration
 * @version 0.1
 * @date 2021-08-4
 *
 * @copyright Copyright (c) 2020
 */
#ifndef MILPPP_EXPRESSION_ALGEBRA_HPP
#define MILPPP_EXPRESSION_ALGEBRA_HPP

#include <numeric>
#include <vector>

#include <range/v3/algorithm/for_each.hpp>
#include <range/v3/view/zip.hpp>

#ifndef MILPPP_LINEAR_CONSTRAINTS_HPP
#define MILPPP_LINEAR_CONSTRAINTS_HPP

#include <numeric>
#include <ostream>
#include <range/v3/algorithm/for_each.hpp>

#ifndef MILPPP_LINEAR_EXPRESSION_HPP
#define MILPPP_LINEAR_EXPRESSION_HPP

#include <iostream>
#include <ostream>
#include <vector>

#include <range/v3/algorithm/for_each.hpp>
#include <range/v3/algorithm/sort.hpp>
#include <range/v3/view/zip.hpp>

namespace fhamonic {
namespace milppp {

struct LinearExpr {
    double constant;
    std::vector<int> vars;
    std::vector<double> coefs;

    LinearExpr() : constant(0) {}

    LinearExpr(LinearExpr && e)
        : constant(e.constant)
        , vars(std::move(e.vars))
        , coefs(std::move(e.coefs)) {
        std::cout << "move LinearExpr" << std::endl;
    }
    LinearExpr(const LinearExpr & e)
        : constant(e.constant), vars(e.vars), coefs(e.coefs) {
        std::cout << "copy LinearExpr" << std::endl;
    }

    LinearExpr(int v, double c = 1.0) : constant(0), vars(1, v), coefs(1, c) {}
    LinearExpr & add(double c) {
        constant += c;
        return *this;
    }
    LinearExpr & add(int v, double c = 1.0) {
        vars.emplace_back(v);
        coefs.emplace_back(c);
        std::cout << "add LinearExpr" << std::endl;
        return *this;
    }
    LinearExpr & simplify() {
        auto zip_view = ranges::view::zip(vars, coefs);
        ranges::sort(zip_view,
                     [](auto p1, auto p2) { return p1.first < p2.first; });

        auto first = zip_view.begin();
        const auto end = zip_view.end();
        for(auto next = first + 1; next != end; ++next) {
            if((*first).first != (*next).first) {
                if((*first).second != 0.0) ++first;
                *first = *next;
                continue;
            }
            (*first).second += (*next).second;
        }
        const std::size_t new_length = static_cast<std::size_t>(
            std::distance(zip_view.begin(), first + 1));
        vars.resize(new_length);
        coefs.resize(new_length);
        return *this;
    }
};

inline std::ostream & operator<<(std::ostream & os, const LinearExpr & e) {
    if(e.vars.size() > 0) {
        std::size_t i = 0;
        os << (e.coefs[i] < 0 ? "-" : "");
        if(std::abs(e.coefs[i]) != 1) os << std::abs(e.coefs[i]) << "*";
        os << "x" << e.vars[i];
        for(++i; i < e.vars.size(); ++i) {
            os << (e.coefs[i] < 0 ? " - " : " + ");
            if(std::abs(e.coefs[i]) != 1) os << std::abs(e.coefs[i]) << "*";
            os << "x" << e.vars[i];
        }
    }
    return os << (e.constant < 0 ? " - " : " + ") << std::abs(e.constant);
}

}  // namespace milppp
}  // namespace fhamonic

#endif  // MILPPP_LINEAR_EXPRESSION_HPP

namespace fhamonic {
namespace milppp {

enum InequalitySense { LESS = -1, EQUAL = 0, GREATER = 1 };

struct LinearIneqConstraint {
    InequalitySense sense;
    LinearExpr linear_expression;
    LinearIneqConstraint() = default;
    LinearIneqConstraint(InequalitySense s, LinearExpr && e)
        : sense(s), linear_expression(std::move(e)){};
    LinearIneqConstraint & simplify() {
        linear_expression.simplify();
        return *this;
    }
};

struct LinearRangeConstraint {
    double lower_bound, upper_bound;
    LinearExpr linear_expression;
    LinearRangeConstraint()
        : lower_bound{std::numeric_limits<double>::min()}
        , upper_bound{std::numeric_limits<double>::max()} {}
};

inline std::ostream & operator<<(std::ostream & os,
                                 const LinearIneqConstraint & constraint) {
    return os << constraint.linear_expression
              << (constraint.sense == LESS ? " <= 0" : " >= 0");
}
inline std::ostream & operator<<(std::ostream & os,
                                 const LinearRangeConstraint & constraint) {
    return os << constraint.lower_bound
              << " <= " << constraint.linear_expression
              << " <= " << constraint.upper_bound;
}

}  // namespace milppp
}  // namespace fhamonic

#endif  // MILPPP_LINEAR_CONSTRAINTS_HPP

#ifndef MILPPP_STRONG_TYPES
#define MILPPP_STRONG_TYPES

namespace fhamonic {
namespace milppp {

class Var {
private:
    int _id;

public:
    constexpr Var(const Var & v) noexcept : _id(v.id()) {}
    explicit constexpr Var(const int & i) noexcept : _id(i) {}
    [[nodiscard]] constexpr int id() const noexcept { return _id; }
};

class Constr {
private:
    int _id;

public:
    constexpr Constr(const Constr & c) noexcept : _id(c.id()) {}
    explicit constexpr Constr(const int & i) noexcept : _id(i) {}
    [[nodiscard]] constexpr int id() const noexcept { return _id; }
};

}  // namespace milppp
}  // namespace fhamonic

#endif  // MILP_BUILDER_STRONG_TYPES

namespace fhamonic {
namespace milppp {

struct LinearTerm {
    double coef;
    int var;

    constexpr LinearTerm(LinearTerm && t)
        : coef(t.coef)
        , var(t.var) { /*std::cout << "move ctor LinearTerm" << std::endl;*/
    }
    constexpr LinearTerm(const LinearTerm & t)
        : coef(t.coef)
        , var(t.var) { /*std::cout << "copy ctor LinearTerm" << std::endl;*/
    }

    constexpr LinearTerm(Var v, double c = 1.0)
        : coef(c)
        , var(v.id()) { /*std::cout << "custom ctor LinearTerm" << std::endl;*/
    }

    constexpr LinearTerm & operator*(double c) {
        coef *= c;
        return *this;
    }
    constexpr LinearTerm & operator-() {
        coef = -coef;
        return *this;
    }
};

constexpr LinearTerm operator*(Var v, double c) {
    LinearTerm t(v, c);
    return t;
}
constexpr LinearTerm operator-(Var v) {
    LinearTerm t(v, -1);
    return t;
}
constexpr LinearTerm operator*(double c, Var v) {
    LinearTerm t(v, c);
    return t;
}

inline LinearExpr & operator+(LinearExpr & e, double c) { return e.add(c); }
inline LinearExpr & operator+(LinearExpr && e, double c) { return e.add(c); }
inline LinearExpr & operator+(LinearExpr & e, const LinearTerm & t) {
    return e.add(t.var, t.coef);
}
inline LinearExpr & operator+(LinearExpr && e, const LinearTerm & t) {
    return e.add(t.var, t.coef);
}

inline LinearExpr operator+(const LinearTerm & t1, const LinearTerm & t2) {
    LinearExpr e(t1.var, t1.coef);
    e + t2;
    return e;
}
inline LinearExpr operator+(const LinearTerm & t, double c) {
    LinearExpr e(t.var, t.coef);
    e.add(c);
    return e;
}
inline LinearExpr operator+(double c, const LinearTerm & t) {
    LinearExpr e(t.var, t.coef);
    e.add(c);
    return e;
}

inline LinearExpr & operator-(LinearExpr & e1, const LinearExpr & e2) {
    e1.constant -= e2.constant;
    ranges::for_each(ranges::view::zip(e2.vars, e2.coefs),
                     [&e1](const auto p) { e1.add(p.first, -p.second); });
    return e1;
}

inline LinearIneqConstraint operator<=(LinearExpr && e1,
                                       const LinearExpr & e2) {
    e1 - e2;
    return LinearIneqConstraint(LESS, std::move(e1));
}
inline LinearIneqConstraint operator>=(LinearExpr && e1,
                                       const LinearExpr & e2) {
    e1 - e2;
    return LinearIneqConstraint(GREATER, std::move(e1));
}
inline LinearIneqConstraint operator<=(LinearExpr & e1, const LinearExpr & e2) {
    return std::move(e1) <= e2;
}
inline LinearIneqConstraint operator>=(LinearExpr & e1, const LinearExpr & e2) {
    return std::move(e1) >= e2;
}

}  // namespace milppp
}  // namespace fhamonic

#endif  // MILPPP_EXPRESSION_ALGEBRA_HPP

namespace fhamonic {
namespace milppp {

class IneqConstraintHandler {
private:
    std::vector<int> & _vars;
    std::vector<double> & _coefs;
    double & bound;

public:
    IneqConstraintHandler(std::vector<int> & vars, std::vector<double> & coefs,
                          double & b)
        : _vars(vars), _coefs(coefs), bound(b) {}

private:
    void lhs_impl(double c) { bound -= c; }
    void lhs_impl(const LinearTerm & t) {
        _vars.push_back(t.var);
        _coefs.push_back(t.coef);
    }

public:
    template <typename... Terms>
    IneqConstraintHandler & lhs(Terms &&... terms) {
        (lhs_impl(terms), ...);
        return *this;
    }

private:
    void rhs_impl(double c) { bound += c; }
    void rhs_impl(const LinearTerm & t) {
        _vars.push_back(t.var);
        _coefs.push_back(-t.coef);
    }

public:
    template <typename... Terms>
    IneqConstraintHandler & rhs(Terms &&... terms) {
        (rhs_impl(terms), ...);
        return *this;
    }
};

class RangeConstraintHandler {
private:
    std::vector<int> & _vars;
    std::vector<double> & _coefs;

public:
    RangeConstraintHandler(std::vector<int> & vars, std::vector<double> & coefs)
        : _vars(vars), _coefs(coefs) {}

private:
    void op_impl(const LinearTerm & t) {
        _vars.push_back(t.var);
        _coefs.push_back(t.coef);
    }

public:
    template <typename... Terms>
    RangeConstraintHandler & operator()(Terms &&... terms) {
        (op_impl(terms), ...);
        return *this;
    }
};

template <typename SolverTraits>
class MILP_Builder {
public:
    static constexpr double MINUS_INFINITY = std::numeric_limits<double>::min();
    static constexpr double INFINITY = std::numeric_limits<double>::max();
    using OptSense = typename SolverTraits::OptSense;
    using ColType = typename SolverTraits::ColType;
    using ModelType = typename SolverTraits::ModelType;

private:
    std::vector<double> _col_coef;
    std::vector<double> _col_lb;
    std::vector<double> _col_ub;
    std::vector<ColType> _col_type;

    std::vector<int> _vars;
    std::vector<double> _coefs;

    std::vector<int> _row_begins;
    std::vector<double> _row_lb;
    std::vector<double> _row_ub;

    OptSense _sense;

public:
    MILP_Builder(OptSense sense) : _sense(sense) {}

    OptSense getOptSense() const { return _sense; }
    MILP_Builder & setOptSense(OptSense s) {
        _sense = s;
        return *this;
    }

    Var addVar(double coef = 0.0, double lb = 0.0, double ub = INFINITY,
               ColType type = ColType::CONTINUOUS) {
        _col_coef.push_back(coef);
        _col_lb.push_back(lb);
        _col_ub.push_back(ub);
        _col_type.push_back(type);
        return Var(static_cast<int>(nbVars() - 1));
    }

private:
    template <typename T, typename... Args>
    auto addVars(pack<Args...>, std::size_t count, T && id_lambda, double coef,
                 double lb, double ub, ColType type) {
        const std::size_t offset = nbVars();
        const std::size_t new_size = offset + count;
        _col_coef.resize(new_size, coef);
        _col_lb.resize(new_size, lb);
        _col_ub.resize(new_size, ub);
        _col_type.resize(new_size, type);
        return [offset, count,
                id_lambda = std::forward<T>(id_lambda)](Args... args) {
            const int id = id_lambda(args...);
            assert(0 <= id && id < count);
            return Var(offset + id);
        };
    }

public:
    template <typename T>
    auto addVars(int count, T && id_lambda, double coef = 0.0, double lb = 0.0,
                 double ub = INFINITY, ColType type = ColType::CONTINUOUS) {
        return addVars(typename function_traits<T>::arg_types(), count,
                       std::forward<T>(id_lambda), coef, lb, ub, type);
    }

    std::size_t nbVars() const { return _col_coef.size(); }
    double getObjCoef(Var v) const {
        return _col_coef[static_cast<std::size_t>(v.id())];
    }
    MILP_Builder & setObjCoef(Var v, double coef) {
        _col_coef[static_cast<std::size_t>(v.id())] = coef;
        return *this;
    }
    double getVarLB(Var v) const {
        return _col_lb[static_cast<std::size_t>(v.id())];
    }
    double getVarUB(Var v) const {
        return _col_ub[static_cast<std::size_t>(v.id())];
    }
    MILP_Builder & setBounds(Var v, double lb, double ub) {
        _col_lb[static_cast<std::size_t>(v.id())] = lb;
        _col_ub[static_cast<std::size_t>(v.id())] = ub;
        return *this;
    }
    ColType getVarType(Var v) const {
        return _col_type[static_cast<std::size_t>(v.id())];
    }
    MILP_Builder & setType(Var v, ColType type) {
        _col_type[static_cast<std::size_t>(v.id())] = type;
        return *this;
    }

    IneqConstraintHandler addLessThanConstr() {
        _row_begins.push_back(static_cast<int>(nbEntries()));
        _row_lb.push_back(MINUS_INFINITY);
        _row_ub.push_back(0);
        IneqConstraintHandler handler(_vars, _coefs, _row_ub.back());
        return handler;
    }
    IneqConstraintHandler addGreaterThanConstr() {
        _row_begins.push_back(static_cast<int>(nbEntries()));
        _row_lb.push_back(0);
        _row_ub.push_back(INFINITY);
        IneqConstraintHandler handler(_vars, _coefs, _row_lb.back());
        return handler;
    }
    RangeConstraintHandler addRangeConstr(double lb, double ub) {
        _row_begins.push_back(static_cast<int>(nbEntries()));
        _row_lb.push_back(lb);
        _row_ub.push_back(ub);
        RangeConstraintHandler handler(_vars, _coefs);
        return handler;
    }

    std::size_t nbConstrs() const { return _row_begins.size(); }
    double getConstrLB(Constr constr) const {
        return _row_lb[static_cast<std::size_t>(constr.id())];
    }
    double getConstrUB(Constr constr) const {
        return _row_ub[static_cast<std::size_t>(constr.id())];
    }
    std::size_t nbEntries() const { return _vars.size(); }

    auto variables() const {
        auto view = ranges::views::transform(
            ranges::iota_view<int, int>(0, static_cast<int>(nbVars())),
            [](int var_id) { return Var(var_id); });
        return view;
    }
    auto constraints() const {
        auto view = ranges::views::transform(
            ranges::iota_view<int, int>(0, static_cast<int>(nbConstrs())),
            [](int constr_id) { return Constr(constr_id); });
        return view;
    }
    auto objective() const {
        auto view = ranges::view::zip(variables(), _col_coef);
        return view;
    }
    const auto entries() const {
        auto view = ranges::view::zip(_vars, _coefs);
        return view;
    }
    const auto entries(Constr constr) const {
        const std::size_t offset = static_cast<std::size_t>(
            _row_begins[static_cast<std::size_t>(constr.id())]);
        const std::size_t end =
            (constr.id() + 1 < static_cast<int>(nbConstrs())
                 ? static_cast<std::size_t>(
                       _row_begins[static_cast<std::size_t>(constr.id()) + 1])
                 : nbEntries());
        auto sub_vars = ranges::views::transform(
            ranges::subrange(
                _vars.begin() + static_cast<std::ptrdiff_t>(offset),
                _vars.begin() + static_cast<std::ptrdiff_t>(end)),
            [](int var_id) { return Var(var_id); });
        auto sub_coefs = ranges::subrange(
            _coefs.begin() + static_cast<std::ptrdiff_t>(offset),
            _coefs.begin() + static_cast<std::ptrdiff_t>(end));
        auto view = ranges::view::zip(sub_vars, sub_coefs);
        return view;
    }

    ModelType build() {
        ModelType model = SolverTraits::build(
            _sense, static_cast<int>(nbVars()), _col_coef.data(),
            _col_lb.data(), _col_ub.data(), _col_type.data(),
            static_cast<int>(nbConstrs()), static_cast<int>(nbEntries()),
            _row_begins.data(), _vars.data(), _coefs.data(), _row_lb.data(),
            _row_ub.data());
        return model;
    }
};

template <typename T>
std::ostream & print_entries(std::ostream & os, const T & e) {
    auto it = e.begin();
    const auto end = e.end();
    if(it == end) return os;
    for(; it != end; ++it) {
        Var v = (*it).first;
        double coef = (*it).second;
        if(coef == 0.0) continue;

        const double abs_coef = std::abs(coef);
        os << (coef < 0 ? "-" : "");
        if(abs_coef != 1) os << abs_coef << " ";
        os << "x" << v.id();
        break;
    }
    for(++it; it != end; ++it) {
        Var v = (*it).first;
        double coef = (*it).second;
        if(coef == 0.0) continue;
        const double abs_coef = std::abs(coef);
        os << (coef < 0 ? " - " : " + ");
        if(abs_coef != 1) os << abs_coef << " ";
        os << "x" << v.id();
    }
    return os;
}

template <typename SolverTraits>
std::ostream & operator<<(std::ostream & os,
                          const MILP_Builder<SolverTraits> & lp) {
    using MILP = MILP_Builder<SolverTraits>;
    os << (lp.getOptSense() == MILP::OptSense::MINIMIZE ? "Minimize"
                                                        : "Maximize")
       << std::endl;
    print_entries(os, lp.objective());
    os << std::endl << "Subject To" << std::endl;
    for(Constr constr : lp.constraints()) {
        const double lb = lp.getConstrLB(constr);
        const double ub = lp.getConstrUB(constr);
        if(ub != MILP::INFINITY) {
            os << "R" << constr.id() << ": ";
            print_entries(os, lp.entries(constr));
            os << " <= " << ub << std::endl;
        }
        if(lb != MILP::MINUS_INFINITY) {
            os << "R" << constr.id() << "_low: ";
            print_entries(os, lp.entries(constr));
            os << " >= " << lb << std::endl;
        }
    }
    auto interger_vars = ranges::filter_view(lp.variables(), [&lp](Var v) {
        return lp.getVarType(v) == MILP::ColType::INTEGER;
    });
    if(ranges::distance(interger_vars) > 0) {
        os << "General" << std::endl;
        for(Var v : interger_vars) {
            os << " x" << v.id();
        }
        os << std::endl;
    }
    auto binary_vars = ranges::filter_view(lp.variables(), [&lp](Var v) {
        return lp.getVarType(v) == MILP::ColType::BINARY;
    });
    if(ranges::distance(binary_vars) > 0) {
        os << "Binary" << std::endl;
        for(Var v : binary_vars) {
            os << " x" << v.id();
        }
        os << std::endl;
    }
    auto no_trivial_bound_vars =
        ranges::filter_view(lp.variables(), [&lp](Var v) {
            return lp.getVarLB(v) != 0.0 || lp.getVarUB(v) != MILP::INFINITY;
        });
    if(ranges::distance(no_trivial_bound_vars) > 0) {
        os << "Bounds" << std::endl;
        for(Var v : no_trivial_bound_vars) {
            if(lp.getVarLB(v) == lp.getVarUB(v)) {
                os << "x" << v.id() << " = " << lp.getVarUB(v) << std::endl;
                continue;
            }
            if(lp.getVarLB(v) != 0.0) {
                if(lp.getVarLB(v) == MILP::MINUS_INFINITY)
                    os << "-Inf <= ";
                else
                    os << lp.getVarLB(v) << " <= ";
            }
            os << "x" << v.id();
            if(lp.getVarUB(v) != MILP::INFINITY) os << " <= " << lp.getVarUB(v);
            os << std::endl;
        }
    }
    return os << "End" << std::endl;
}

}  // namespace milppp
}  // namespace fhamonic

#endif  // MILPPP_MILP_BUILDER_HPP

#ifndef MILPPP_GUROBI_TRAITS_HPP
#define MILPPP_GUROBI_TRAITS_HPP

#include <gurobi_c.h>

namespace fhamonic {
namespace milppp {

struct GRBModelWrap {
    GRBenv * env;
    GRBmodel * model;
    GRBModelWrap() : env(nullptr), model(nullptr) {}
    GRBModelWrap(GRBenv * e, GRBmodel * m) : env(e), model(m) {}
    ~GRBModelWrap() {
        if(model != nullptr) GRBfreemodel(model);
        if(env != nullptr) GRBfreeenv(env);
    }
};

struct GrbTraits {
    enum OptSense : int { MINIMIZE = GRB_MINIMIZE, MAXIMIZE = GRB_MAXIMIZE };
    enum ColType : char {
        CONTINUOUS = GRB_CONTINUOUS,
        INTEGER = GRB_INTEGER,
        BINARY = GRB_BINARY
    };
    using ModelType = GRBModelWrap;

    static GRBModelWrap build(OptSense opt_sense, int nb_vars, double * obj,
                              double * col_lb, double * col_ub, ColType * vtype,
                              int nb_rows, int nb_elems, int * row_begins,
                              int * indices, double * coefs, double * row_lb,
                              double * row_ub) {
        GRBModelWrap grb;
        GRBemptyenv(&grb.env);
        GRBstartenv(grb.env);

        GRBsetintparam(grb.env, GRB_INT_PAR_LOGTOCONSOLE, 0);

        GRBnewmodel(grb.env, &grb.model, "PL", nb_vars, obj, col_lb, col_ub,
                    reinterpret_cast<char *>(vtype), NULL);
        GRBaddrangeconstrs(grb.model, nb_rows, nb_elems, row_begins, indices,
                           coefs, row_lb, row_ub, NULL);
        GRBsetintattr(grb.model, GRB_INT_ATTR_MODELSENSE, opt_sense);

        return grb;
    }
};

}  // namespace milppp
}  // namespace fhamonic

#endif  // MILPPP_GUROBI_TRAITS_HPP

#endif //MILPPP_HPP